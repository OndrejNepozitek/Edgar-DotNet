(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{149:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var r=n(1),a=n(9),o=(n(0),n(163)),i={id:"chainBasedGenerator",title:"Chain based generator",sidebar_label:"Introduction"},l={id:"version-1.0.6/chainBasedGenerator",title:"Chain based generator",description:"This whole section is about the `ChainBasedGenerator` class which is the class that connects all the building blocks that are needed to generate layouts.\r",source:"@site/versioned_docs\\version-1.0.6\\chainBasedGenerator.md",permalink:"/ProceduralLevelGenerator/docs/chainBasedGenerator",editUrl:"https://github.com/OndrejNepozitek/ProceduralLevelGenerator/tree/docusaurus/versioned_docs/version-1.0.6/chainBasedGenerator.md",version:"1.0.6",sidebar_label:"Introduction"},c=[{value:"High-level structure",id:"high-level-structure",children:[]},{value:"Used terms",id:"used-terms",children:[{value:"Node",id:"node",children:[]},{value:"Configuration",id:"configuration",children:[]}]}],s={rightToc:c};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This whole section is about the ",Object(o.b)("inlineCode",{parentName:"p"},"ChainBasedGenerator")," class which is the class that connects all the building blocks that are needed to generate layouts."),Object(o.b)("p",null,"The generator was implemented with ",Object(o.b)("em",{parentName:"p"},"extensibility")," in mind and pretty much any part of the algorithm can be replaced with a custom implementation. Pages in this section explain all the building blocks of the algorithm and show how to extend the algorithm."),Object(o.b)("h2",{id:"high-level-structure"},"High-level structure"),Object(o.b)("p",null,"The generator is made of following building blocks:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"/ProceduralLevelGenerator/docs/configurationSpaces"}),"Configuration spaces")," - knows which polygon positions are valid"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"layoutEvolvers.md"}),"Layout evolver")," - evolution of valid partial layouts"),Object(o.b)("li",{parentName:"ul"},"Chain decomposition - decomposing input graphs into chains"),Object(o.b)("li",{parentName:"ul"},"Layout operations - layout perturbations and energy handling"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"/ProceduralLevelGenerator/docs/configurationSpaces"}),"Generator planner")," - directing which layouts are further evolved"),Object(o.b)("li",{parentName:"ul"},"Layout converter - converting layouts from their internal representation to something more useful")),Object(o.b)("p",null,"The basic idea is that the input graph is decomposed into chains (e.g. sets of vertices). Layouts are then created incrementally by adding chains one by one. After adding a chain, the algorithm starts with a possibly not valid partial layout and uses a layout evolver (currently simulated annealing) to evolve a valid layout. Another chain is then added until a full layout is generated. See the following diagram:"),Object(o.b)("p",null,Object(o.b)("img",Object(r.a)({parentName:"p"},{src:"assets/diagram.svg",alt:"alt-text"}))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," It would seem that a generator planner is the most complicated part of the layout generator. Well, it's like the exact opposite - there is like nothing more to it that is not already shown. It's just important for imagining how the whole algorithm works but most of the ",Object(o.b)("em",{parentName:"p"},"magic")," happens in ",Object(o.b)("em",{parentName:"p"},"layout evolvers"),"."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," ",Object(o.b)("em",{parentName:"p"},"Layout operations")," and ",Object(o.b)("em",{parentName:"p"},"configuration spaces")," are not shown in the diagram but they are extensively used in layout evolvers."),Object(o.b)("h2",{id:"used-terms"},"Used terms"),Object(o.b)("h3",{id:"node"},"Node"),Object(o.b)("h3",{id:"configuration"},"Configuration"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Configuration")," is a term used when referring to the state of a given node in the layout. It contains information mainly about the position and the shape of the node. It also holds information about the energy of the node and anything that is useful in the process."))}u.isMDXComponent=!0},163:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),u=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},p=function(e){var t=u(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},h=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=u(n),h=r,b=p["".concat(i,".").concat(h)]||p[h]||d[h]||o;return n?a.a.createElement(b,l({ref:t},s,{components:n})):a.a.createElement(b,l({ref:t},s))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);